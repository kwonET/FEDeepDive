# JS DEEP DIVE STUDY
[도서] <strong>모던 자바스크립트 Deep Dive</strong> 도서의 학습한 내용을 정리합니다. <br />
매주 학습한 내용을 정리하고, 월요일 22:00 디스코드에서 발표 및 토의를 진행합니다.

## 1주차

#### Chapter1. 프로그래밍

#### Chapter2. 자바스크립트란?

#### Chapter3. 자바스크립트 개발 환경과 실행 방법

<details>
<summary>Chapter4. 변수</summary>
<div markdown="1">

### 4.1 변수란?
- 메모리(1바이트 단위)에 데이터를 저장
- 메모리 셀은 각자 메모리 주소를 가짐.
- 해당 메모리 주소의 값을 CPU가 읽어서 표현식의 연산 수행
- 이러한 메모리 공간을 재사용하기 위해, 변수가 만들어짐

- 변수 : 하나의 값을 저장하기 위해 확보한 메모리 공간 자체, 혹은 그 공간을 식별하기 위한 이름
	- 할당 : 변수에 값을 저장
	- 참조 : 변수에 저장된 값을 읽어들임			

### 4.2 식별자
- 식별자 : 어떤 값을 구별해서 식별할 수 있는 고유한 이름
	- 값이 저장되어있는 메모리 주소와 매핑관계
	- 매핑 정보도 메모리에 저장됨
	- 즉, 식별자는 값이 아니라 메모리 주소를 기억함

- 함수, 클래스, 변수 모두 고유한 메모리 공간을 가지고 식별할 수 있으므로 식별자에 해당한다.


### 4.3 변수 선언
- 변수를 선언한다 == 변수를 생성한다. 메모리 공간을 확보하고 변수 이름과 공간을 연결해 저장할 수 있게 준비하는 것
	- var, let, const(ES6) 활용
	* 키워드: var과 같이, js엔진이 수행할 동작이 규정되어있는 명령어

- 암묵적으로 선언과 동시에 undefined값이 할당됨
	- 그렇기에 이전에 다른 application에서 사용했던 값이 남아있는 garbage value 문제를 막을 수 있음

- Reference Error : 식별자를 통해 값을 참조하려 했지만 js엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러
- 식별자와 스코프는 실행 context에서 관리된다.


### 4.4 변수 선언의 실행 시점과 변수 호이스팅
```
console.log(score); //undefined
var score =1;
```
- js 코드는 인터프리터에 의해 한줄 씩 순차적으로 실행된다.
- 변수 선언은 런타임(소스코드가 한 줄씩 실행되는 시점)이 아니라, 그 이전 단계에서 먼저 실행된다.
	- 변수 선언이 다른 코드보다 먼저 실행된다.
	- js 엔진은 런타임 전에 소스코드의 평가 과정을 거친다.
	- 이때 변수 선언을 포함한 모든 선언문을 먼저 실행한다.
- 변수 호이스팅 : 변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 특징


### 4.5 값의 할당
- 선언과 다르게 할당은 런타임에 실행됨
- 선언 이후 값을 할당될 때는 선언된 메모리 주소의 값이 변경되는 것이 아니다. 새로운 메모리 공간을 확보하고 할당 값을 넣는다.

```
console.log(score); //undefined
score =1;
var score;
console.log(score); //1
```

### 4.6 값의 재할당
- 상수는 재할당할 수 없다.
- 재할당되면 이전에 할당되었던 메모리 공간은 garbage가 된다. 메모리에서 언제 해제될지는 알 수 없다. garbage collector가 수행한다.
	- 따라서 메모리의 할당과 해제를 관여할 수 없기에 js는 unmanaged language다.


### 4.7 식별자 네이밍 규칙
- 카멜 케이스 : firstName
- 스네이크 케이스 : first_name
- 파스칼 케이스 : FirstName
- 헝가리언 케이스 : strFirstName


</div>
</details>



#### Chapter5. 표현식과 문

#### Chapter6. 데이터 타입

#### Chapter7. 연산자

#### Chapter8. 제어문

#### Chapter9. 타입 변환과 단축 평가

#### Chapter10. 객체 리터럴

#### Chapter11. 원시 값과 객체의 비교


<details>
<summary>Chapter13. 스코프</summary>
<div markdown="1">


### 13.1 스코프란?
- 함수의 매개변수가 함수 몸체 내부에서만 참조할 수 있는 유효범위와 관련이 있다
- 변수, 함수, 클래스 이름 (모든 식별자) : 자신이 선언된 위치에 의해 유효범위 (다른 코드가 변수를 참조할 수 있는 범위)가 결정됨
	- 이를 스코프라 한다. 
	- 스코프 : 식별자가 유효한 범위

- 식별자 결정: js엔진이 스코프를 통해 어떤 변수를 참조해야할지 결정하는 것
	- 스코프란, js엔진이 식별자를 검색할 때 사용하는 규칙이기도 하다.
	* 코드 context는 lexical 환경으로 이루어진다. 이를 실행 context로 구현하였으며, 모든 코드가 실행 context에서 실행된다.
	- 스코프를 통해 같은 이름의 변수를 구분한다. 즉, 스코프는 네임스페이스다.


### 13.2 스코프의 종류
- 코드의 구분
	- 전역 코드 / 지역 코드
	- 변수는 자신이 선언된 위치에 따라 스코프가 결정됨
	- 전역에서 설정된 전역 스코프를 갖는 전역 변수 / 지역에서 설정된 지역 스코프를 갖는 지역 변수
지역 스코프

	- 전역 : 코드의 가장 바깥 영역	
	- 지역 : 함수 몸체 내부
- 지역 변수는 자신의 지역 스코프와 하위 스코프에서 유효함
- 참조할 변수를 검색하는 것은 스코프 체인에 따라서.


### 13.3 스코프 체인
- 중첩 함수 형태에서는 스코프가 계층적 구조를 갖게 된다
- 모든 지역 스코프의 최상위 스코프는 전역 스코프

#### 13.3.1 스코프 체인과 변수 검색
- 변수 참조시, js엔진은 스코프 체인에 따라 변수를 참조하는 스코프에서 시작해 상위 방향으로 이동하며 선언된 변수를 검색(identifier resolution)함.
- 물리적 실체
	- js엔진이 코드 실행 전 {식별자 : 렉시컬 환경} [자료구조]을 만든다

- 하위 스코프의 유효변수를 상위 스코프에서는 참조할 수 없음
	- 상속에서, 자식의 자산을 부모가 사용할 수 없는 것과 유사한 개념

#### 13.3.2 스코프 체인과 함수 검색
- 함수 선언문 시, 런타임 이전에 함수 객체가 생성
js엔진이 함수이름의 식별자를 만듦 -> 
그 후 만들어진 함수 객체가 식별자에 할당됨.
- 즉 함수도 식별자에 해당하고, 그렇기에 스코프를 가짐.
- 따라서 스코프는 '변수를 검색하는 규칙'이라기 보다 더 범용적으로 '식별자를 검색하는 규칙'이 맞음.


### 13.4 함수 레벨 스코프
- 코드 블록이 아닌 함수에 의해 지역 스코프가 생성됨.
- var : 함수의 코드 블록을 지역 스코프로 인정
	- const, let :  블록 스코프 지원


### 13.5 렉시컬 스코프
```
var x = 1
function foo(){
    var x = 10;
    bar()
}
function bar(){
    console.log(x)
}
foo(); //1
bar(); // 1
```

bar 함수의 상위 스코프는?
1) 함수가 어디서 호출됐는지 (동적 스코프)
	- 선언되는 시점이 아닌 호출되는 시점에 동적으로 추적
2) 함수가 어디서 정의됐는지 (렉시컬, 정적 스코프)
	- 함수 정의가 평가되는 시점에서 정적으로

- 함수의 상위 스코프는 자신이 정의된 스코프이다.
- 그렇기에 bar함수의 상위 스코프는 전역 스코프이다.


</div>
</details>



#### Chapter14. 



<br/>

## 2주차

## 3주차

## 4주차

## 5주차

## 6주차

## 7주차

## 8주차

## 9주차

## 10주차

## 11주차

## 12주차
